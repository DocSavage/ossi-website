---
// import merge from 'lodash.merge';
// import type { ImageMetadata } from 'astro';
// import { getCollection } from "astro:content";
import Layout from '~/layouts/PageLayout.astro';
import Headline from '~/components/blog/Headline.astro';
import List from '~/components/blog/List.astro';
import Filters from "~/components/widgets/Filters.astro";
// import SinglePost from '~/components/blog/SinglePost.astro';
// import ToBlogLink from '~/components/blog/ToBlogLink.astro';

// import { getCanonical, getPermalink } from '~/utils/permalinks';
import { fetchPosts } from '~/utils/blog';
// import { findImage } from '~/utils/images';

// export const prerender = true;

// export async function getStaticPaths () {
//   return await getStaticPathsBlogPost();
// }

// const { post } = Astro.props;

// const url = getCanonical(getPermalink(post.permalink, 'post'));
// const image = (await findImage(post.image)) as ImageMetadata | undefined;

// const metadata = merge(
//   {
//     title: post.title,
//     description: post.excerpt,
//     robots: {
//       index: blogPostRobots?.index,
//       follow: blogPostRobots?.follow,
//     },
//     openGraph: {
//       type: 'article',
//       ...(image ? { images: [{ url: image, width: image?.width, height: image?.height }] } : {}),
//     },
//   },
//   { ...(post?.metadata ? { ...post.metadata, canonical: post.metadata?.canonical || url } : {}) }
// );

// function generateTagCombinations(tags) {
//   const tagCombinations = new Set();

//   // Iterate over all possible combinations
//   for (let i = 1; i <= tags.length; i++) {
//     for (let j = 0; j <= tags.length - i; j++) {
//       const combination = tags.slice(j, j + i).join('&');
//       tagCombinations.add(combination);
//     }
//   }

//   return tagCombinations;
// }

// function filterProjectsByTagCombinations(projects, tagCombinations) {
//   return tagCombinations.map(tagCombination => {
//     const tagsToMatch = tagCombination.split('&');

//     const filteredProjects = projects.filter(project =>
//       tagsToMatch.every(tag => project.data.tags.includes(tag))
//     );

//     return {
//       params: { tagCombination },
//       props: { projects: filteredProjects },
//     };
//   });
// }

const posts = await fetchPosts("projects")
// export async function getStaticPaths() {
//   const allProjects = await getCollection("projects");
//   const uniqueTags = [...new Set(allProjects.map((project) => project.data.tags).flat())];
//   const uniqueTagCombinations = generateTagCombinations(uniqueTags)

//   return filterProjectsByTagCombinations(allProjects, uniqueTagCombinations)
// }


// console.log(posts)
---

<Layout>
  <section class="px-6 sm:px-6 py-12 sm:py-16 lg:py-20 mx-auto max-w-4xl">
    <Headline
      subtitle="OSSI-supported projects"
    >
      Projects List
    </Headline>
    <section class="grid grid-cols-3 gap-4 border-2 border-green-700">
      <div class="col-span-1 border-2 border-red-700">
        <Filters/>
      </div>
      <div class="col-start-2 col-span-2">
        <List posts={posts}></List>
      </div>
      
    </section>
  </section>
</Layout>
